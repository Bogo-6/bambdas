<!--
*** AUTO-GENERATED FILE ***
This file is auto-generated by BambdaChecker.
Please do not manually edit this file, or include any changes to this file in pull requests.
-->
# Proxy HTTP
Documentation: [Filtering the HTTP history with Bambdas](https://portswigger.net/burp/documentation/desktop/tools/proxy/http-history/bambdas)
## [FilterHighlightAnnotateOWASP.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterHighlightAnnotateOWASP.bambda)
### Filters Proxy HTTP history for requests with vulnerable parameters based on the OWASP Top 25 using the parameter arrays written by Tur24Tur / BugBountyzip (https://github.com/BugBountyzip).
#### Author: Shain Lakin (https://github.com/flamebarke/SkittlesBambda)
```java
// Define vulnerable parameter group record
record VulnParamGroup(String title, HighlightColor color, String... parameterNames) {}

// Vulnerable Parameter Groups
VulnParamGroup ssrf = new VulnParamGroup("SSRF", HighlightColor.GREEN, "dest", "redirect", "uri", "path", "continue", "url", "window", "next", "data", "reference", "site", "html", "val", "validate", "domain", "callback", "return", "page", "feed", "host", "port", "to", "out", "view", "dir");
VulnParamGroup sql = new VulnParamGroup("SQL", HighlightColor.BLUE, "id", "page", "report", "dir", "search", "category", "file", "class", "url", "news", "item", "menu", "lang", "name", "ref", "title", "view", "topic", "thread", "type", "date", "form", "main", "nav", "region");
VulnParamGroup xss = new VulnParamGroup("XSS", HighlightColor.ORANGE, "q", "s", "search", "id", "lang", "keyword", "query", "page", "keywords", "year", "view", "email", "type", "name", "p", "month", "image", "list_type", "url", "terms", "categoryid", "key", "l", "begindate", "enddate");
VulnParamGroup lfi = new VulnParamGroup("LFI", HighlightColor.YELLOW, "cat", "dir", "action", "board", "date", "detail", "file", "download", "path", "folder", "prefix", "include", "page", "inc", "locate", "show", "doc", "site", "type", "view", "content", "document", "layout", "mod", "conf");
VulnParamGroup or = new VulnParamGroup("OR", HighlightColor.PINK, "next", "url", "target", "rurl", "dest", "destination", "redir", "redirect_uri", "redirect_url", "redirect", "out", "view", "to", "image_url", "go", "return", "returnTo", "return_to", "checkout_url", "continue", "return_path");
VulnParamGroup rce = new VulnParamGroup("RCE", HighlightColor.RED, "cmd", "exec", "command", "execute", "ping", "query", "jump", "code", "reg", "do", "func", "arg", "option", "load", "process", "step", "read", "feature", "exe", "module", "payload", "run", "print");

// Toggle for highlighting
boolean highlightEnabled = true;

// Set multi vulnerable parameter group colour
HighlightColor multipleVulnColor = HighlightColor.MAGENTA;
VulnParamGroup[] groups = {ssrf, sql, xss, lfi, or, rce};
Set<String> foundParams = new HashSet<>();
Map<HighlightColor, Integer> colorCounts = new HashMap<>();
String combinedNotes = "";

// Get the request object
var request = requestResponse.request();

// Main loop to check for matches
for (VulnParamGroup group : groups) {
    for (String paramName : group.parameterNames()) {
        if (request.hasParameter(paramName, HttpParameterType.URL) ||
            request.hasParameter(paramName, HttpParameterType.BODY)) {
            if (highlightEnabled) {
                foundParams.add(group.title() + ": " + paramName);
                colorCounts.put(group.color(), colorCounts.getOrDefault(group.color(), 0) + 1);
            }
            // Return if only one vulnerability class applies
            if (!highlightEnabled) {
                requestResponse.annotations().setHighlightColor(group.color());
                return true;
            }
        }
    }
}

// If more than one vulnerability class applies set the multi vulnerable parameter colour
if (!foundParams.isEmpty()) {
    HighlightColor highlightColor = multipleVulnColor;
    if (colorCounts.size() == 1) {
        highlightColor = colorCounts.keySet().iterator().next();
    }

    requestResponse.annotations().setHighlightColor(highlightColor);
    combinedNotes = String.join(", ", foundParams);
    requestResponse.annotations().setNotes(combinedNotes);
    return true;
}

return false;

```
## [FilterOnCookieValue.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOnCookieValue.bambda)
### Filters Proxy HTTP history for requests with a specific Cookie value.
#### Author: LostCoder
```java
if (requestResponse.request().hasParameter("foo", HttpParameterType.COOKIE)) {
	var cookieValue = requestResponse
		.request()
		.parameter("foo", HttpParameterType.COOKIE)
		.value();

	return cookieValue.contains("1337");
}

return false;

```
## [FilterOnSpecificHighlightColor.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOnSpecificHighlightColor.bambda)
### Filters requests/responses for specific highlight colors
#### Author: Nick Coblentz (https://github.com/ncoblentz)
```java
return requestResponse.annotations().highlightColor().equals(HighlightColor.CYAN);

```
## [FilterOutOptionsRequests.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOutOptionsRequests.bambda)
### Filter out OPTIONS requests.
#### Author: Trikster
```java
return !requestResponse.request().method().equals("OPTIONS");

```
## [FindJSONresponsesWithIncorrectContentType.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FindJSONresponsesWithIncorrectContentType.bambda)
### Finds JSON responses with wrong Content-Type  The content is probably json but the content type is not application/json
#### Author: albinowax
```java
var contentType = requestResponse.hasResponse() ? requestResponse.response().headerValue("Content-Type") : null;

if (contentType != null && !contentType.contains("application/json")) {
 String body = requestResponse.response().bodyToString().trim();

 return body.startsWith( "{" ) || body.startsWith( "[" );
}

return false;

```
## [HighlightDeprecatedHTTPMethods.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/HighlightDeprecatedHTTPMethods.bambda)
### Filters and highlights requests using less common or deprecated HTTP methods like TRACE or CONNECT.
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
boolean manualColorHighlightEnabled = true;

// Define the set of deprecated or less common HTTP methods
Set<String> deprecatedMethods = Set.of("TRACE", "CONNECT");

String requestMethod = requestResponse.request().method();

// Check if the request method is in the set of deprecated methods
if (deprecatedMethods.contains(requestMethod)) {
    if (manualColorHighlightEnabled) {
        // Set the highlight color to RED
        requestResponse.annotations().setHighlightColor(HighlightColor.RED);

        // Optionally, add a note to the request/response
        requestResponse.annotations().setNotes("Deprecated method used: " + requestMethod);
    }
    return true;
}

return false;

```
## [HighlightResponsesWithDeveloperNotes.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/HighlightResponsesWithDeveloperNotes.bambda)
### Bambda Script to Highlight Responses with Developer Notes This script identifies and highlights HTTP responses containing developer notes in HTML and JavaScript files. It highlights HTML responses in green and JavaScript responses in yellow.
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
boolean manualColorHighlightEnabled = true;

// Ensure there is a response and it is not null
if (!requestResponse.hasResponse()) {
    return false;
}

// Use mimeType() for content type detection
MimeType responseType = requestResponse.response().mimeType();
boolean isHtml = responseType == MimeType.HTML;
boolean isJavaScript = responseType == MimeType.SCRIPT;

// Process only HTML and JavaScript responses
if (!isHtml && !isJavaScript) {
    return false;
}

boolean foundDeveloperNotes = false;
StringBuilder notesBuilder = new StringBuilder();
HighlightColor highlightColor = isHtml ? HighlightColor.GREEN : HighlightColor.YELLOW;

String responseBody = requestResponse.response().bodyToString();
String[] commentPatterns = isHtml ? new String[]{"<!--(?!\\[if).*?(?<!\\])-->"} : new String[]{"/\\*\\*(.*?)\\*\\*/"};


for (String pattern : commentPatterns) {
    Pattern regexPattern = Pattern.compile(pattern, Pattern.DOTALL);
    Matcher matcher = regexPattern.matcher(responseBody);

    while (matcher.find()) {
        foundDeveloperNotes = true;
        if (manualColorHighlightEnabled) {
            String note = matcher.group();
            // Limit the note length to 250 characters
            if (note.length() > 250) {
                note = note.substring(0, 250) + "...";
            }

            if (notesBuilder.length() > 0) {
                notesBuilder.append("; ");
            }
            notesBuilder.append("Developer note found: ").append(note);
        }
    }
}

if (foundDeveloperNotes) {
    requestResponse.annotations().setHighlightColor(highlightColor);
    if (manualColorHighlightEnabled && notesBuilder.length() > 0) {
        requestResponse.annotations().setNotes(notesBuilder.toString());
    }
}

return foundDeveloperNotes;

```
## [HighlightUnencryptedHTTP.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/HighlightUnencryptedHTTP.bambda)
### Bambda Script to Highlight Unencrypted HTTP Traffic Filters Proxy HTTP history for unencrypted (non-HTTPS) requests.
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
// Get the request object from the requestResponse
var request = requestResponse.request();

// Extract the URL from the request
var requestUrl = request.url();

// Check if the request URL starts with "http://"
if (requestUrl.startsWith("http://")) {
    // URL is unencrypted, return true to highlight this request
    return true;
}

// URL is encrypted or does not match the criteria, return false
return false;

```
## [OWASPTop25VulnerableParameters.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/OWASPTop25VulnerableParameters.bambda)
### Filters Proxy HTTP history for requests with vulnerable parameters based on the OWASP Top 25
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
// Define the vulnerable parameters as a Set based on OWASP Top 25
Set<String> parameterNames = Set.of(
    // SSRF parameters
    "dest", "redirect", "uri", "continue", "url", "window", "data",
    "reference", "site", "html", "val", "validate", "domain", "callback", "return",
    "page", "feed", "host", "port", "to", "out", "dir",
    // SQL injection parameters
    "id", "select", "report", "search", "category", "file", "class", "news",
    "item", "menu", "ref", "title", "topic", "thread",
    "form", "main", "nav", "region",
    // XSS parameters
    "q", "s", "lang", "keyword", "keywords", "year", "email",
    "type", "name", "p", "month", "image", "list_type", "terms", "categoryid", "key",
    "l", "begindate", "enddate",
    // LFI parameters
    "cat", "action", "board", "date", "detail", "download", "path", "folder",
    "prefix", "include", "inc", "locate", "show", "doc", "view",
    "content", "document", "layout", "mod", "conf",
    // Open Redirect parameters
    "next", "target", "rurl", "destination", "redir", "redirect_uri",
    "redirect_url", "image_url", "go",
    "returnTo", "return_to", "checkout_url", "return_path",
    // RCE parameters
    "cmd", "exec", "command", "execute", "ping", "query", "jump", "code", "reg", "do",
    "func", "arg", "option", "load", "process", "step", "read", "feature", "exe",
    "module", "payload", "run", "print"
);

// Get the request object
var request = requestResponse.request();

// Iterate through each parameter name and check if it exists in the request URL or body
for (String param : parameterNames) {
    if (request.hasParameter(param, HttpParameterType.URL) ||
        request.hasParameter(param, HttpParameterType.BODY)) {
        return true;
    }
}

return false;

```
